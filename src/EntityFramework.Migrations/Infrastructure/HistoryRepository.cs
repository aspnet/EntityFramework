// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using JetBrains.Annotations;
using Microsoft.Data.Entity.Infrastructure;
using Microsoft.Data.Entity.Metadata;
using Microsoft.Data.Entity.Migrations.Utilities;
using Microsoft.Data.Entity.Relational;

namespace Microsoft.Data.Entity.Migrations.Infrastructure
{
    public class HistoryRepository
    {
        internal static readonly string ProductVersion = typeof(HistoryRepository).GetTypeInfo().Assembly.GetInformationalVersion();

        private readonly DbContextConfiguration _contextConfiguration;
        private IModel _historyModel;
        private DbContextOptions _contextOptions;

        public HistoryRepository([NotNull] DbContextConfiguration contextConfiguration)
        {
            Check.NotNull(contextConfiguration, "contextConfiguration");

            _contextConfiguration = contextConfiguration;
        }

        public virtual SchemaQualifiedName TableName
        {
            get { return "__MigrationHistory"; }
        }

        public virtual IModel HistoryModel
        {
            get { return _historyModel ?? (_historyModel = CreateHistoryModel()); }
        }

        public virtual IReadOnlyList<IMigrationMetadata> Migrations
        {
            get
            {
                using (var historyContext = CreateHistoryContext())
                {
                    return GetMigrationsQuery(historyContext).ToArray();
                }
            }
        }

        protected virtual DbContextConfiguration ContextConfiguration
        {
            get { return _contextConfiguration; }
        }

        protected virtual DbContextOptions HistoryContextOptions
        {
            get { return _contextOptions ?? (_contextOptions = CreateHistoryContextOptions()); }
        }

        public virtual DbContext CreateHistoryContext()
        {
            return new DbContext(ContextConfiguration.Services.ServiceProvider, HistoryContextOptions);
        }

        public virtual IQueryable<IMigrationMetadata> GetMigrationsQuery([NotNull] DbContext historyContext)
        {
            Check.NotNull(historyContext, "historyContext");

            return
                historyContext.Set<HistoryRow>()
                    .Where(h => h.ContextKey == GetContextKey())
                    .OrderBy(h => h.MigrationId)
                    .Select(h => new MigrationMetadata(h.MigrationId));
        }

        public virtual IReadOnlyList<SqlStatement> GenerateInsertMigrationSql(
            [NotNull] IMigrationMetadata migration, [NotNull] SqlGenerator sqlGenerator)
        {
            Check.NotNull(migration, "migration");
            Check.NotNull(sqlGenerator, "sqlGenerator");

            // TODO: Implement a mechanism to capture the SQL generated by 
            // the update pipeline (context.Add, context.SaveChanges) and use here.

            var stringBuilder = new StringBuilder();
            stringBuilder
                .Append("INSERT INTO ")
                .Append(sqlGenerator.DelimitIdentifier(TableName))
                .Append(" (")
                .Append(sqlGenerator.DelimitIdentifier("MigrationId"))
                .Append(", ")
                .Append(sqlGenerator.DelimitIdentifier("ContextKey"))
                .Append(", ")
                .Append(sqlGenerator.DelimitIdentifier("ProductVersion"))
                .Append(") VALUES (")
                .Append(sqlGenerator.GenerateLiteral(migration.MigrationId))
                .Append(", ")
                .Append(sqlGenerator.GenerateLiteral(GetContextKey()))
                .Append(", ")
                .Append(sqlGenerator.GenerateLiteral(ProductVersion))
                .Append(")");

            return new[] { new SqlStatement(stringBuilder.ToString()) };
        }

        public virtual IReadOnlyList<SqlStatement> GenerateDeleteMigrationSql(
            [NotNull] IMigrationMetadata migration, [NotNull] SqlGenerator sqlGenerator)
        {
            Check.NotNull(migration, "migration");
            Check.NotNull(sqlGenerator, "sqlGenerator");

            // TODO: Implement a mechanism to capture the SQL generated by 
            // the update pipeline (context.Delete, context.SaveChanges) and use here.

            var stringBuilder = new StringBuilder();
            stringBuilder
                .Append("DELETE FROM ")
                .Append(sqlGenerator.DelimitIdentifier(TableName))
                .Append(" WHERE ")
                .Append(sqlGenerator.DelimitIdentifier("MigrationId"))
                .Append(" = ")
                .Append(sqlGenerator.GenerateLiteral(migration.MigrationId))
                .Append(" AND ")
                .Append(sqlGenerator.DelimitIdentifier("ContextKey"))
                .Append(" = ")
                .Append(sqlGenerator.GenerateLiteral(GetContextKey()));

            return new[] { new SqlStatement(stringBuilder.ToString()) };
        }

        protected virtual IModel CreateHistoryModel()
        {
            var builder = new BasicModelBuilder();

            builder.Entity<HistoryRow>(b =>
                {
                    b.Key(e => new { e.MigrationId, e.ContextKey });
                    b.Property(e => e.MigrationId).Required().ColumnMaxLength(150);
                    b.Property(e => e.ContextKey).Required().ColumnMaxLength(300);
                    b.Property(e => e.ProductVersion).Required().ColumnMaxLength(32);
                    b.ToTable(TableName);
                });

            return builder.Model;
        }

        protected virtual DbContextOptions CreateHistoryContextOptions()
        {
            var contextOptions = new DbContextOptions().UseModel(HistoryModel);
            var contextOptionsExtensions = (IDbContextOptionsExtensions)contextOptions;

            // TODO: Figure out whether it is ok to reuse all the extensions
            // from the user context configuration for the history context.
            foreach (var item in ContextConfiguration.ContextOptions.Extensions)
            {
                var extension = item;
                contextOptionsExtensions.AddExtension(extension);
            }

            return contextOptions;
        }

        protected virtual string GetContextKey()
        {
            return ContextConfiguration.Context.GetType().FullName;
        }

        private class HistoryRow
        {
            public string MigrationId { get; set; }
            public string ContextKey { get; set; }
            public string ProductVersion { get; set; }
        }
    }
}
